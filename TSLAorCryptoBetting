// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

contract PriceConsumerV3 {

    AggregatorV3Interface internal priceFeed;
    
    int public yourBet;
    uint public betAmount;
    /**
     * should be TSLA ETH or BTC
     */
    string public bettingOn;
    int public actualPrice;
    int private betDifference;
    int public accuracyPercentage;
    int public prizeAmount;
    
    address payable public owner;
    address private TSLAAddr; 
    address private ETHAddr; 
    address private BTCAddr; 
    
    /**
     * Network: Kovan
     * Aggregator: TSLA/USD
     * TSLA Address: 0xb31357d152638fd1ae0853d24b9Ea81dF29E3EF2
     */

    /**
     * Network: Rinkeby
     * Aggregator: ETH/USD
     * ETH Address: 0x8A753747A1Fa494EC906cE90E9f37563A8AF630e
     */
     
    /**
     * Network: Rinkeby
     * Aggregator: BTC/USD
     * TSLA Address: 0xECe365B379E1dD183B20fc5f022230C044d51404
     */
    constructor() {
        address owner = msg.sender;
        TSLAAddr = 0xb31357d152638fd1ae0853d24b9Ea81dF29E3EF2;
        ETHAddr = 0x8A753747A1Fa494EC906cE90E9f37563A8AF630e;
        BTCAddr = 0xECe365B379E1dD183B20fc5f022230C044d51404;
        // set it to the 0 address by default
        priceFeed = AggregatorV3Interface(address(0));
    }
    
    modifier validBet (uint _amount) {
        require(msg.value >= 0, "Have to bet more than 0");
        require(msg.sender.balance >= _amount, "Don't have enough funds to make bet");
        _;
    }
    
    /**
     * (make this charge money based on how much you want to bet) Done
     * (Need to make it check that _bettingOn is either "TSLA" "ETH" or "BTC") Done
     * (need to make it check that bet amount is less than the money they own) Done
     */
    function placeBet(int _pricePediction, uint _betAmount, string calldata _bettingOn) public payable validBet(_betAmount){
        require(_pricePediction > 0, "invalid price prediction");
        // require that they bet on BTC ETH or TSLA
        require(keccak256(bytes(_bettingOn)) == keccak256(bytes("TSLA"))
        || keccak256(bytes(bettingOn)) == keccak256(bytes("ETH"))
        || keccak256(bytes(bettingOn)) == keccak256(bytes("BTC")));
        owner.transfer(msg.value);
        yourBet = _pricePediction;
        betAmount = _betAmount;
        bettingOn = _bettingOn;
    }

    /**
     * Returns the latest price using chainlink oracle
     */
    function getLatestPrice() public returns (int) {
        if (keccak256(bytes(bettingOn)) == keccak256(bytes("TSLA"))){
            priceFeed = AggregatorV3Interface(TSLAAddr);
        }
        
        if (keccak256(bytes(bettingOn)) == keccak256(bytes("ETH"))){
            priceFeed = AggregatorV3Interface(ETHAddr);
        }
        
        if (keccak256(bytes(bettingOn)) == keccak256(bytes("BTC"))){
            priceFeed = AggregatorV3Interface(BTCAddr);
        }

        (
            uint80 roundID, 
            int price,
            uint startedAt,
            uint timeStamp,
            uint80 answeredInRound
        ) = priceFeed.latestRoundData();
        // converts price to int
        actualPrice = price/10**8;
        return actualPrice;
    }
    
    /**
     * finds how close the bet was to the actual price in terms of a percentage rounded to an int
     */
    function betAccuracy() public returns (int) {
        betDifference = abs(yourBet - actualPrice);
        accuracyPercentage = betDifference/actualPrice * 100;
        return abs(accuracyPercentage);
    }
    
    /**
     * Give prizes based on how close the bet was
     * (need to change to return crypto prizes based on bet amount)
     */
    function calculatePrize() public returns (int) {
        if (accuracyPercentage < 2) {
            return(prizeAmount = 100);
        }
        if (2 <= accuracyPercentage && accuracyPercentage < 5) {
            return(prizeAmount = 50);
        }
        else {
            return(prizeAmount = 0);
        }
    }
    
    /**
     * absolute value helper function
     */
    function abs(int x) private pure returns (int) {
        return x >= 0 ? x : -x;
    }
}
