// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

contract PriceConsumerV3 {

    AggregatorV3Interface internal priceFeed;
    
    int public yourBet;
    int public betAmount;
    /**
     * should be TSLA ETH or BTC
     */
    string public bettingOn;
    int public actualPrice;
    int public absBetAccuracy;
    int public prizeAmount;
    
    address private TSLAAddr; 
    address private ETHAddr; 
    address private BTCAddr; 
    
    /**
     * Network: Kovan
     * Aggregator: TSLA/USD
     * TSLA Address: 0xb31357d152638fd1ae0853d24b9Ea81dF29E3EF2
     */

    /**
     * Network: Rinkeby
     * Aggregator: ETH/USD
     * ETH Address: 0x8A753747A1Fa494EC906cE90E9f37563A8AF630e
     */
     
    /**
     * Network: Rinkeby
     * Aggregator: BTC/USD
     * TSLA Address: 0xECe365B379E1dD183B20fc5f022230C044d51404
     */
    constructor() {
        TSLAAddr = 0xb31357d152638fd1ae0853d24b9Ea81dF29E3EF2;
        ETHAddr = 0x8A753747A1Fa494EC906cE90E9f37563A8AF630e;
        BTCAddr = 0xECe365B379E1dD183B20fc5f022230C044d51404;
        // set it to the 0 address by default
        priceFeed = AggregatorV3Interface(address(0));
    }
    
    /**
     * (make this charge money based on how much you want to bet)
     * (Need to make it check that _bettingOn is either "TSLA" "ETH" or "BTC")
     * (need to make it check that bet amount is less than the money they own)
     */
    function placeBet(int _pricePediction, int _betAmount, string calldata _bettingOn) public {
        require(_pricePediction > 0, "invalid price prediction");
        require(_betAmount > 0, "invalid bet amount");
        //require(_bettingOn == "TSLA" || _bettingOn == "ETH" || _bettingOn == "BTC");
        yourBet = _pricePediction;
        betAmount = _betAmount;
        bettingOn = _bettingOn;
    }

    /**
     * Returns the latest price using chainlink oracle
     */
    function getLatestPrice() public returns (int) {
        if (keccak256(bytes(bettingOn)) == keccak256(bytes("TSLA"))){
            priceFeed = AggregatorV3Interface(TSLAAddr);
        }
        
        if (keccak256(bytes(bettingOn)) == keccak256(bytes("ETH"))){
            priceFeed = AggregatorV3Interface(ETHAddr);
        }
        
        if (keccak256(bytes(bettingOn)) == keccak256(bytes("BTC"))){
            priceFeed = AggregatorV3Interface(BTCAddr);
        }

        (
            uint80 roundID, 
            int price,
            uint startedAt,
            uint timeStamp,
            uint80 answeredInRound
        ) = priceFeed.latestRoundData();
        // converts price to int
        actualPrice = price/10**8;
        return actualPrice;
    }
    
    /**
     * finds the absolute value of the difference between your bet and the actual price
     */
    function betAccuracy() public returns (int) {
        absBetAccuracy = abs(yourBet - actualPrice);
        return abs(yourBet - actualPrice);
    }
    
    /**
     * Give prizes based on how close the bet was
     * (need to change to return crypto prizes based on bet amount)
     */
    function calculatePrize() public returns (int) {
        if (absBetAccuracy < 2) {
            return(prizeAmount = 100);
        }
        if (2 <= absBetAccuracy && absBetAccuracy < 5) {
            return(prizeAmount = 50);
        }
        else {
            return(prizeAmount = 0);
        }
    }
    
    /**
     * absolute value helper function
     */
    function abs(int x) private pure returns (int) {
        return x >= 0 ? x : -x;
    }
}
